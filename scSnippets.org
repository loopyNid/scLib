* sc
**  evaluation in org mode

https://code.orgmode.org/bzg/org-mode/src/master/contrib/lisp/ob-sclang.el
* snippets
** first snippet start and stop audio
#+BEGIN_SRC sclang
  a = {SinOsc.ar()};
  fork{
      a.play;
      3.wait;
      thisProcess.stop;
  }
#+END_SRC

#+RESULTS:
: a = {SinOsc.ar()};
: fork{
:     a.play;
:     3.wait;
:     thisProcess.stop;
: }

** 6-5-18_euclidean rhythms
#+BEGIN_SRC sclang
  (
  // tempo
  ~tempo = 1;
  ///////// patter init
  //// v
  ~v = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16th note array
  ~x = 5; // number of notes played per loop. this value should be 8 at most
  ~interV = (~v.size/~x).round; //
  for(1, ~v.size, {|i|
      if(i%~interV == 0, {
          ~v[i-1] = 1;
      });
      i.postln;
  });

  ////// v1
  ~v1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16th note array
  ~x1 = 4;
  ~interV1 = (~v1.size/~x1).round; //

  for(1, ~v1.size, {|i|
      if(i%~interV1 == 0, {
          ~v1[i-1] = 1;
      });
      i.postln;
  });

  ////// v2
  ~v2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16th note array
  ~x2 = 3;
  ~interV2 = (~v2.size/~x2).round; //

  for(1, ~v2.size, {|i|
      if(i%~interV2 == 0, {
          ~v2[i-1] = 1;
      });
      i.postln;
  });


  //v = v.rotate((~interV.asInteger/2).asInteger);
  ~v.postln;
  ~v1.postln;
  ~v2.postln;

  SynthDef(\jzf, {|freq = 89, vol = 0.5, envDur = 1, gate = 1|
      var src, env;
      env =  EnvGen.kr(Env.new([0, 1, 0], [envDur/2, envDur/2]), gate: 1, doneAction: 2);
      src = SinOsc.ar([freq, freq]);
      Out.ar(0, src * vol * 0.2 * env);
  }).add;

  // SynthDef(\ioi, {| freq = 60, vol = 0.5, envDur = 1|
  //     var src, env;
  //     env = EnvGen.kr(Env.new([0, 1, 0], [envDur/2, envDur/2]), gate:1, doneAction: 2);
  //     src = PinkNoise.ar([freq, freq]);
  //     Out.ar(0, src * vol * 0.2 * env);
  // }).add;

  SynthDef(\ioi,{|freq = 50, vol = 0.6, envDur = 1|
      var src, env, envgen;
      env = Env.new([0, 1, 0],[envDur/2,envDur/2], \sine);
      envgen = EnvGen.kr(env, gate: 1, doneAction: 2);
      src  = LFTri.ar([freq, freq],0,vol*(Pulse.ar(15,0.5)*SinOsc.ar(15)));
      Out.ar(0, (vol)*src*envgen);
  }).add;

  SynthDef(\ioi1, {| freq = 60, vol = 0.5, envDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [envDur/2, envDur/2]), gate:1, doneAction: 2);
      src = SinOsc.ar([freq, freq], 0.4);
      Out.ar(0, src * vol * 0.2 * env);
  }).add;


  fork{

      j = Scale.phrygian;

      Pdef(\ioi, Pbind(\instrument, \ioi,
          \envDur, ~tempo,
          \dur, ~tempo,
          \freq, 60,
          \vol, 1
      )).play;

      6.wait;

      inf.do({


          Pdef(\nid1, Pbind(\instrument, \jzf,
              \envDur, ~tempo/4,
              \dur, ~tempo/4,
              \vol, Pseq(~v, inf),
              \freq, 466,
          )).play;

          10.wait;

          Pdef(\nid2, Pbind(\instrument, \ioi,
              \envDur, ~tempo/4,
              \dur, ~tempo/4,
              \vol, Pseq(~v1, inf),
              \freq, 329.63
          )).play;

          10.wait;

          Pdef(\nid3, Pbind(\instrument, \ioi,
              \envDur, ~tempo/4,
              \dur, ~tempo/4,
              \vol, Pseq(~v2, inf),
              \degree, Prand([0, 1, 3, 5, 7, 9], inf),
              \scale, Pfunc({ j }, inf),
              \root, -1,
          )).play;

          10.wait;

          ~tempo = ~tempo - 0.01;

      });

  }

  )

  //play{Blip.ar([WhiteNoise.kr(10)*5, WhiteNoise.kr(10)*(SinOsc.ar(50) * 10)])};

  ~v.postln;

  ~v = ~v.rotate(1);

  ~v1.postln;

  ~v1 = ~v1.rotate(2);

  ~v2.postln;

  ~v2 = ~v2.rotate(5);
#+END_SRC
** 16-5-18
#+BEGIN_SRC sclang
  (

  TempoClock.default.tempo = 130/60;

  ~sample = Buffer.read(s, Platform.userHomeDir +/+ "scLib/samples/santoriniPort.wav");

  SynthDef(\6, {|amp = 0.5, rate = 1, starP = 0|
      var src;
      src = PlayBuf.ar(2, 3, rate, 1, starP, 0, doneAction: 2);
      Out.ar(0, src * amp);
  }).play;

  {PlayBuf.ar(2, 3)}

  SynthDef(\1, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = SinOsc.ar(freq, 0, BrownNoise.kr());
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\2, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 0.7, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = SinOsc.ar(freq, 0, LFTri.kr(1));
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\3, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = WhiteNoise.ar(SinOsc.kr(0.1) * Dust.kr());
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\4, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = FreeVerb.ar(SinOsc.ar(freq, 0, SinOsc.kr(0.1)));
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\5, {| freq = 45, amp = 0.5|
      var src, env;
      env = EnvGen.kr(Env.perc());
      src = LFTri.ar(freq);
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  )
  //play{Blip.ar([WhiteNoise.kr(10)*5, WhiteNoise.kr(10)*(SinOsc.ar(50) * 10)])};
  (
  fork{

      ~a =  Pbind(\instrument, \1,
          \dur, 5,
          \eDur, 10,
          \midinote , [60, 64, 70, 73]
      );

      ~b = Pbind(\instrument, \2,
          \dur, 5,
          \eDur, 10,
          \midinote , [60, 64, 70, 73]
      );

      ~c = Pbind(\instrument, \3,
          \dur, 120,
          \eDur, 120
      );

      ~d = Pbind(\instrument, \4,
          \dur, 0.2,
          \eDur, 0.4,
          \midinote , Prand([84, 88, 94], inf),
          \amp, 0.1
      );

      Pdef(\a, ~a).play;

      Pdef(\b, ~b).play;

      Pdef(\c, ~c).play;

      Pdef(\d, ~d).play;
  }

  )
#+END_SRC
** 17-5-18
#+BEGIN_SRC sclang

  TempoClock.default.tempo = 100/60;

  (

  SynthDef(\11, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = SinOsc.ar(freq, 0, BrownNoise.kr());
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\21, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 0.7, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = SinOsc.ar(freq, 0, LFTri.kr(5));
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\3, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = WhiteNoise.ar(SinOsc.kr(0.01));
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;

  SynthDef(\4, {| freq = 300, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([1, 1, 0], [eDur/2,eDur/2]), gate: 1, doneAction:2);
      src = FreeVerb.ar(SinOsc.ar(freq, 0, SinOsc.kr(0.1)));
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;
  )

  (
  SynthDef(\1, {|freq = 49, amp = 0.5, eDur = 1|
      var src, env;
      env = EnvGen.kr(Env.new([0, 1, 0], [(3*eDur)/4,eDur/4]), gate: 1, doneAction: 2);
      src = SinOsc.ar(freq);
      Out.ar(0, Pan2.ar(src) * env * amp);
  }).add;
  )

  (
  SynthDef(\2, {|freq = 45, amp = 0.5|
      var src, env;
      env = EnvGen.kr(Env.perc());
      src = SinOsc.ar(freq);
      Out.ar(0, Pan2.ar(src) * amp * env);
  }).add;
  )

  (
  Pbind(\instrument, \11,
      \eDur, 1,
      \dur, 1,
      \midinote, Prand([60, 70, 67, 65,], inf)
  ).play(quant: 1);
  )



  (
  Pbind(\instrument, \2,
      \freq, 90,
      \dur, 1
  ).play(quant: 1);
  )
#+END_SRC
** 18-5-18
#+BEGIN_SRC sclang
  (
  //// v
  ~v = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16th note array
  ~x = 3; // number of notes played per loop. this value should be 8 at most
  ~interV = (~v.size/~x).round; //
  for(1, ~v.size, {|i|
      if(i%~interV == 0, {
          ~v[i-1] = 1;
      });
      i.postln;
  });
  )
  (
  //// v1
  ~v1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; // 16th note array
  ~x = 4; // number of notes played per loop. this value should be 8 at most
  ~interV = (~v1.size/~x).round; //
  for(1, ~v1.size, {|i|
      if(i%~interV == 0, {
          ~v1[i-1] = 1;
      });
      i.postln;
  });
  )
  (
  TempoClock.default.tempo = 200/60;

  t = TempoClock.default.tempo;

  ~sample = Buffer.read(s, Platform.userHomeDir +/+ "scLib/samples/santoriniPort.wav");
  ~sample1 = Buffer.read(s, Platform.userHomeDir +/+ "scLib/samples/scatemono.wav");


  SynthDef(\hello, {|rate, trigger, stP, loop, amp, eDur, dur |
      var src, env;
      env = EnvGen.kr(Env.new([0,1,0],[dur/2,dur/2]), gate: 1, doneAction: 2);
      src = PlayBuf.ar(1, 1, rate, trigger, stP, loop, doneAction: 2);
      Out.ar(0,Pan2.ar(src)  * env * amp *2);
  }).add;

  SynthDef(\hell, {|rate, trigger, stP, loop, amp, eDur, dur |
      var src, env;
      env = EnvGen.kr(Env.new([0,1,0],[dur/2,dur/2]), gate: 1, doneAction: 2);
      src = PlayBuf.ar(2, 0, rate, trigger, stP, loop, doneAction: 2);
      Out.ar(0,src * env  * amp);
  }).add;

  SynthDef(\hel, {|freq, amp, eDur|
      var src, env;
      env = EnvGen.kr(Env.perc(), gate: 1, doneAction: 2);
      src = LFTri.ar(freq).softclip;
      Out.ar(0, Pan2.ar(src) * env * amp * 0.4);
  }).add;

  SynthDef(\hel1, {|freq, amp, eDur|
      var src, env;
      env = EnvGen.kr(Env.perc(), gate: 1, doneAction: 2);
      src = LFTri.ar(freq, 0, amp/2) + LFSaw.ar(freq, 0, amp/2);
      Out.ar(0, Pan2.ar(src) * env * amp);
  }).add;

  SynthDef(\hel11, {|freq, amp, eDur|
      var src, env;
      env = EnvGen.kr(Env.perc(), gate: 1, doneAction: 2);
      src =  FreeVerb.ar(Blip.ar(freq) + SinOsc.ar(freq));//SinOsc.ar(freq);
      Out.ar(0, Pan2.ar(src) * env * amp);
  }).add;

  )



  (
  Pdef(\1, Pbind(\instrument, \hel,
      \dur, 1,
      \amp, Pseq([ 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 ],inf),
      \midinote, Pseq([28], inf)
  )).play(quant: 1);
  )
  (
  ~v = ~v.rotate(1);
  Pdef(\11, Pbind(\instrument, \hel1,
      \dur, 0.5,
      \amp, Pseq(~v, inf) * 0.5,
      \midinote, Pseq([[40, 47]], inf)
  )).play(quant: 1);
  )
  (
  ~v1 = ~v1.rotate(1);
  Pdef(\111, Pbind(\instrument, \hel11,
      \dur, 0.5,
      \amp, Pseq(~v1, inf) * 0.05,
      \midinote, Prand([55], inf)
  )).play(quant: 1);
  )

  (
  Pdef(\2, Pbind(\instrument, \hell,
      \amp, 0.1,
      \dur, 2,
      \rate, Pseq([16,8,4,8], inf),
      \trigger, 1,
      \stP, 0.33,//Pseq([0.33, 0.66, 0.5], inf),
      \loop, 0
  )).play(quant: 1);
  )

  (
  Pdef(\3, Pbind(\instrument, \hello,
      \amp, 1.5,
      \dur, 2,
      \rate, 0.5,//Pseq([16,8,4,8], inf),
      \trigger, 1,
      \stP, 0.66,//Pseq([0.33, 0.66, 0.5], inf),
      \loop, 0
  )).play(quant: 1);
  )

  )
  s.boot
#+END_SRC
* sc examples
** 17-5-18 (Pxrand([Pmonoâ€¦], inf).play(quant:1); example - tempo - techno)
#+BEGIN_SRC sclang
  //: Pxrand-Pmono
  (
  SynthDef(\bass, { |out, freq = 440, gate = 1, amp = 0.5, slideTime = 0.17, ffreq = 1100, width = 0.15,
          detune = 1.005, preamp = 4|
      var    sig,
          env = Env.adsr(0.01, 0.3, 0.4, 0.1);
      freq = Lag.kr(freq, slideTime);
      sig = Mix(VarSaw.ar([freq, freq * detune], 0, width, preamp)).distort * amp
          ,* EnvGen.kr(env, gate, doneAction: 2);
      sig = LPF.ar(sig, ffreq);
      Out.ar(out, sig ! 2)
  }).add;
  TempoClock.default.tempo = 132/60;
  p = Pxrand([
      Pbind(
          \instrument, \bass,
          \midinote, 36,
          \dur, Pseq([0.75, 0.25, 0.25, 0.25, 0.5], 1),
          \legato, Pseq([0.9, 0.3, 0.3, 0.3, 0.3], 1),
          \amp, 0.5, \detune, 1.005
      ),
      Pmono(\bass,
          \midinote, Pseq([36, 48, 36], 1),
          \dur, Pseq([0.25, 0.25, 0.5], 1),
          \amp, 0.5, \detune, 1.005
      ),
      Pmono(\bass,
          \midinote, Pseq([36, 42, 41, 33], 1),
          \dur, Pseq([0.25, 0.25, 0.25, 0.75], 1),
          \amp, 0.5, \detune, 1.005
      ),
      Pmono(\bass,
          \midinote, Pseq([36, 39, 36, 42], 1),
          \dur, Pseq([0.25, 0.5, 0.25, 0.5], 1),
          \amp, 0.5, \detune, 1.005
      )
  ], inf).play(quant: 1);
  )
  // totally cheesy, but who could resist?
  (
  SynthDef(\kik, { |out, preamp = 1, amp = 1|
      var    freq = EnvGen.kr(Env([400, 66], [0.08], -3)),
          sig = SinOsc.ar(freq, 0.5pi, preamp).distort * amp
              ,* EnvGen.kr(Env([0, 1, 0.8, 0], [0.01, 0.1, 0.2]), doneAction: 2);
      Out.ar(out, sig ! 2);
  }).add;
  // before you play:
  // what do you anticipate '\delta, 1' will do?
  k = Pbind(\instrument, \kik, \delta, 1, \preamp, 4.5, \amp, 0.32).play(quant: 1);
  )
  p.stop;
  k.stop;

#+END_SRC
** 17-5-18 (Pfx, Pfxg, Pgroup, Pbus , examples)
#+BEGIN_SRC sclang
  //: See more on supercollider help
  //: Ppar
  (
  var a, b;
  a = Pbind(\note, Pseq([7, 4, 0], 4), \dur, Pseq([1, 0.5, 1.5], inf));
  b = Pbind(\note, Pseq([5, 10, 12], 4), \dur, 1);
  c = Pbind(\note, Pseq([3, 1, 10], 4), \dur, Pseq([1, 0.5, 1.5], inf));
  d = Pbind(\note, Pseq([6, 9, 12], 4), \dur, 1);
  Pseq([Ppar([ a, b ]), Ppar([c, d])], 2).play;
  )
  //:Pgroup
  p = Pbind(\degree, Prand((0..7), inf), \dur, 0.3, \legato, 0.2);
   // watch the node structure as it changes
  s.waitForBoot({ s.plotTree });
  // one group
  Pgroup(p).play;
  // two nested groups
  Pgroup(Pgroup(p)).play;
  Pgroup(Ppar([Pgroup(p), Pgroup(p)])).play;
  //:Pfx
  (
  SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
      var env, in;
      env = Linen.kr(gate, 0.05, 1, 0.1, 2);
      in = In.ar(out, 2);
      XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
  }, [\ir, \ir, 0.1, 0.1, 0]).add;
  SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
      var env;
      env = Linen.kr(gate, 0.05, 1, 0.1, 2);
      XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
  }, [\ir, 0.1, 0.1, 0]).add;
  SynthDef(\wah, { arg out=0, gate=1;
      var env, in;
      env = Linen.kr(gate, 0.05, 1, 0.4, 2);
      in = In.ar(out, 2);
      XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
  }, [\ir, 0]).add;
  )
  s.waitForBoot({ s.plotTree });
  (
  var p, q, r, o;
  p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
  q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);
  r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);
  o = Pfx(r, \wah);
  Pseq([p, q, r, o], 2).play;
  )
  //:Pfxb
  (
  var p, q, r, o;
  p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
  q = Pfxb(p, \echo, \dtime, 0.2, \decay, 3);
  r = Pfxb(q, \distort, \pregain, 20, \amp, 0.25);
  o = Pfxb(r, \wah);
  Pseq([p, q, r, o], 2).play;
  )
  // test order of effect chain
  (
  SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
      var env, in;
      env = Linen.kr(gate, 0.05, 1, 0.1, 2);
      in = In.ar(out, 2);
      XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
  }, [\ir, \ir, 0.1, 0.1, 0]).add;
  SynthDef(\addbeeps, { arg out=0, gate=1;
      var env;
      env = Linen.kr(gate, 0.05, 1, 0.1, 2);
      XOut.ar(out, env, (In.ar(out, 2) + (LFPulse.kr(1, 0, 0.3) * SinOsc.ar(1000) * 0.4) ));
  }, [\ir, 0.1, 0.1, 0]).add;
  )
  (
  var a;
  a = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
  a = Pfxb(a, \echo, \dtime, 0.2, \decay, 3);
  a = Pfxb(a, \addbeeps);
  a.play;
  )
  //:Pbus
  (
  SynthDef(\echo, { arg out=0, maxdtime=0.2, dtime=0.2, decay=2, gate=1;
      var env, in;
      env = Linen.kr(gate, 0.05, 1, 0.1, 2);
      in = In.ar(out, 2);
      XOut.ar(out, env, CombL.ar(in * env, maxdtime, dtime, decay, 1, in));
  }, [\ir, \ir, 0.1, 0.1, 0]).add;
  SynthDef(\distort, { arg out=0, pregain=40, amp=0.2, gate=1;
      var env;
      env = Linen.kr(gate, 0.05, 1, 0.1, 2);
      XOut.ar(out, env, (In.ar(out, 2) * pregain).distort * amp);
  }, [\ir, 0.1, 0.1, 0]).add;
  SynthDef(\wah, { arg out=0, gate=1;
      var env, in;
      env = Linen.kr(gate, 0.05, 1, 0.4, 2);
      in = In.ar(out, 2);
      XOut.ar(out, env, RLPF.ar(in, LinExp.kr(LFNoise1.kr(0.3), -1, 1, 200, 8000), 0.1).softclip * 0.8);
  }, [\ir, 0]).add;
  )
   // watch the node structure as it changes
  s.waitForBoot({ s.plotTree });
  (
  var p, q, r, o;
  p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
  q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);
  r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);
  o = Pfx(r, \wah);
  Ppar(
      [p, q, r, o].collect(Pbus(_)); // play each in a different bus.
  ).play;
  )
  // compare to playing them together on one bus.
  (
  var p, q, r, o;
  p = Pbind(\degree, Prand((0..7),12), \dur, 0.3, \legato, 0.2);
  q = Pfx(p, \echo, \dtime, 0.2, \decay, 3);
  r = Pfx(q, \distort, \pregain, 20, \amp, 0.25);
  o = Pfx(r, \wah);
  Ppar([p, q, r, o]).play;
  )

#+END_SRC
** 22-5-18
#+BEGIN_SRC sclang
  (
  var synth;
  synth= {| carrfreq=440, modfreq=1, moddepth=0.01|
  SinOsc.ar(carrfreq + MouseX.kr(moddepth, 5000, 'exponential')*SinOsc.ar(MouseY.kr(modfreq, 10000, 'exponential')),0,0.25)
  }.scope;
  )

  (
  SynthDef(\1, {|carrfreq = 440, modfreq = 1, moddepth = 0.01, amp|
      var src;
      src = SinOsc.ar(carrfreq + modfreq*SinOsc.ar(modfreq),0,0.25);
      Out.ar(0, Pan2.ar(src) * amp);
  }).add;
  )
  (
  Pdef(\nid, Pbind(\instrument, \1,
      \dur, 0.2,
      \carrfreq, Pseq([10000,5000,2500,1250], inf),
      \modfreq, Pseq([1000, 2000, 4000, 8000], inf),
      \amp , 0.1
  )).play;
  )

  (
  //This example is from The SuperCollider Book (Wilson, 2011 p.37)
  {

      Mix.ar(
      Array.fill(12,
          {|count|
          var harm;
          harm = count + 1 * 110; // remeber precedence: count + 1, then * 110
              SinOsc.ar(harm, mul: max(0,  SinOsc.kr(count+1/4))
              )*1/(count+1)
  })

  )*0.7


  }.play;
  )

  (
  SynthDef(\2, {|amp = 0.5, harm|
      var src;
      src = {

          Mix.ar(
              Array.fill(12,
                  {|count|
                      harm = count + 1 * 110; // remeber precedence: count + 1, then * 110
                      SinOsc.ar(harm, mul: max(0,  SinOsc.kr(count+1/4))
                      )*1/(count+1)
                  })

          )*0.7


      };
      Out.ar(0, src);
  }).add;
  )

  Synth(\2);
  (
  Pdef(\nid2, Pbind(\instrument, \2,

  )).play
  )

  b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");

  (
  {
      var trate, dur, clk, pos, pan;
      trate = MouseY.kr(8,120,1);
      dur = 12 / trate;
      clk = Impulse.kr(trate);
      pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
      pan = WhiteNoise.kr(0.6);
      TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
  }.scope(2, zoom: 4);
  )

  (
  SynthDef(\3, {|trate, pos|
      var src;
      src = {
      var  dur, clk, pan;
      // trate = MouseY.kr(8,120,1);
      dur = 12 / trate;
      clk = Impulse.kr(trate);
      // pos = MouseX.kr(0,BufDur.kr(b)) + TRand.kr(0, 0.01, clk);
      pan = WhiteNoise.kr(0.6);
      TGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);
      };
      Out.ar(0, src);
  }).add;
  )

  Synth(\3);
  (
  Pdef(\nid3, Pbind(\instrument, \3,
      \dur, 10,
      \trate, Pseq([100, 80, 120, 40],inf),
      \pos, Prand([0.234524, 0.457568756, 0.345624576778, 0.9876673])
  )).play;
  )

  (
  b = Buffer.alloc(s, 512, 1, {| buf | buf.sine1Msg(1.0/[1,2,3,4,5,6,7,8,9,10])});
  { LPF.ar(COsc.ar(b.bufnum, [200.rand.postln, 1000.rand], 0.7, 0.25)*Saw.ar(440+444.rand, WhiteNoise.kr(0.7)), 4000) }.play;
  )

  (
  SynthDef(\4, {|dur, amp, nid, nid1, nid3|
      var src;
      src = { LPF.ar(COsc.ar(b.bufnum, [nid, nid1], 0.7, 0.25)*Saw.ar(nid3, WhiteNoise.kr(amp)), 4000) };
      Out.ar(0, src);
  }).add;
  )

  Pdef(\nid4, Pbind(\instrument, \4,
      \nid, Pseq([100, 1000, 10000], inf),
      \nid1, Pseq([2000, 2300, 2200], inf),
      \nid3, 300
  )).play;
#+END_SRC
